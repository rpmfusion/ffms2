From 354940823be5002556dd827f0130faa7f656c139 Mon Sep 17 00:00:00 2001
From: myrsloik <fredrik.mellbin@gmail.com>
Date: Sun, 16 Oct 2016 17:27:03 +0200
Subject: [PATCH] Remove no longer needed ffmscompat.h abstractions, part1

---
 include/ffmscompat.h             | 23 ---------------
 src/config/libs.cpp              | 44 +---------------------------
 src/config/msvc-config.h         | 49 --------------------------------
 src/core/audiosource.cpp         | 10 ++-----
 src/core/utils.h                 |  7 +----
 src/core/videoutils.cpp          |  2 +-
 src/vapoursynth/vapoursource.cpp | 10 +++----
 7 files changed, 11 insertions(+), 134 deletions(-)
 delete mode 100644 src/config/msvc-config.h

diff --git a/include/ffmscompat.h b/include/ffmscompat.h
index 70c477e12..af615ac68 100644
--- a/include/ffmscompat.h
+++ b/include/ffmscompat.h
@@ -122,29 +122,6 @@ static const AVPixFmtDescriptor *av_pix_fmt_desc_get(AVPixelFormat pix_fmt) {
 #	if VERSION_CHECK(LIBAVUTIL_VERSION_INT, <, 52, 9, 0, 52, 20, 100)
 #		define av_frame_alloc avcodec_alloc_frame
 #	endif
-
-#	if VERSION_CHECK(LIBAVUTIL_VERSION_INT, >, 55, 0, 0, 55, 0, 100) || defined(FF_API_PLUS1_MINUS1)
-#		define FFMS_DEPTH(x) ((x).depth)
-#	else
-#		define FFMS_DEPTH(x) ((x).depth_minus1 + 1)
-#	endif
-#endif
-
-
-#ifndef WITH_SWRESAMPLE
-#define ffms_convert(AVAudioResampleContext, output, out_plane_size, byte_per_sample_src, out_samples, input, in_plane_size, byte_per_sample_target, in_samples) \
-		avresample_convert(AVAudioResampleContext, output, out_plane_size*byte_per_sample_src, out_samples, input, in_plane_size*byte_per_sample_target, in_samples)
-#define ffms_open_resampler(context) avresample_open(context)
-#define FFMS_ResampleContext         AVAudioResampleContext
-#define ffms_resample_alloc_context  avresample_alloc_context
-#define ffms_resample_free           avresample_free
-#else
-#define ffms_convert(AVAudioResampleContext, output, out_plane_size, byte_per_sample_src, out_samples, input, in_plane_size, bps, in_samples) \
-		swr_convert(AVAudioResampleContext, output, out_samples, (const uint8_t**) input, in_samples)
-#define ffms_open_resampler(context) swr_init(context)
-#define FFMS_ResampleContext         SwrContext
-#define ffms_resample_alloc_context  swr_alloc
-#define ffms_resample_free           swr_free
 #endif
 
 #endif // FFMSCOMPAT_H
diff --git a/src/config/libs.cpp b/src/config/libs.cpp
index 0ee8b049b..640ea17ee 100644
--- a/src/config/libs.cpp
+++ b/src/config/libs.cpp
@@ -18,60 +18,18 @@
 //  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 //  THE SOFTWARE.
 
-#include "msvc-config.h"
-
 extern "C" {
 #include <libavutil/avutil.h>
 }
 
-// someone claimed that the borland c++ compiler defines _MSC_VER too,
-// but nobody cares about borland so let them suffer.
+// fixme, just move to project already
 #ifdef _MSC_VER
 
-
-#ifdef WITH_GCC_LIBAV
-// Standard mingw libraries.
-#pragma comment(lib, "libgcc.a")
-#pragma comment(lib, "libmoldname.a")
-#pragma comment(lib, "libmingwex.a")
-#pragma comment(lib, "libz.a")
-#pragma comment(lib, "libwsock32.a")
-#else
 #pragma comment(lib, "zlib.lib")
-#endif /* WITH_GCC_LIBAV */
-
-// libav/ffmpeg libs are the same (name) regardless of their compiler.
 #pragma comment(lib, "libavutil.a")
 #pragma comment(lib, "libavcodec.a")
 #pragma comment(lib, "libavformat.a")
 #pragma comment(lib, "libswscale.a")
-#ifdef WITH_SWRESAMPLE
 #pragma comment(lib, "libswresample.a")
-#else
-#pragma comment(lib, "libavresample.a")
-#endif
-
-#ifdef WITH_OPENCORE_AMR_NB
-#ifdef WITH_GCC_LIBAV
-#pragma comment(lib, "libopencore-amrnb.a")
-#else
-#pragma comment(lib, "opencore-amrnb.lib")
-#endif /* WITH_GCC_LIBAV */
-#endif /* WITH_OPENCORE_AMR_NB */
-
-#ifdef WITH_OPENCORE_AMR_WB
-#ifdef WITH_GCC_LIBAV
-#pragma comment(lib, "libopencore-amrwb.a")
-#else
-#pragma comment(lib, "opencore-amrwb.lib")
-#endif /* WITH_GCC_LIBAV */
-#endif /* WITH_OPENCORE_AMR_WB */
-
-#if defined(WITH_PTHREAD_GC2) && defined(WITH_GCC_LIBAV)
-#pragma comment(lib, "libpthreadGC2.a")
-#elif defined(WITH_PTHREAD_GC2) && !defined(WITH_GCC_LIBAV)
-#error pthreads is only supported if libav/ffmpeg was built with gcc.
-#endif /* defined(WITH_PTHREAD_GC2) && defined(WITH_GCC_LIBAV) */
-
 
 #endif /* _MSC_VER */
diff --git a/src/config/msvc-config.h b/src/config/msvc-config.h
deleted file mode 100644
index dce228bbb..000000000
--- a/src/config/msvc-config.h
+++ /dev/null
@@ -1,49 +0,0 @@
-//  Copyright (c) 2009 Karl Blomster
-//
-//  Permission is hereby granted, free of charge, to any person obtaining a copy
-//  of this software and associated documentation files (the "Software"), to deal
-//  in the Software without restriction, including without limitation the rights
-//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-//  copies of the Software, and to permit persons to whom the Software is
-//  furnished to do so, subject to the following conditions:
-//
-//  The above copyright notice and this permission notice shall be included in
-//  all copies or substantial portions of the Software.
-//
-//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-//  THE SOFTWARE.
-
-
-/*
-By default we will assume that libav/ffmpeg and any dependencies were compiled
-with msvc.  This avoids any hacks that were required with linking mingw stuff
-in msvc.
-
-Compiling libav/ffmpeg with gcc on windows targets (mingw) is still possible.
-Certain third-party libraries may require that libav/ffmpeg be built with gcc.
-
-Define WITH_GCC_LIBAV if the ffmpeg/libav you're linking to was built with gcc.
-*/
-
-//#define	WITH_GCC_LIBAV
-
-/*
-If you want to change what libraries FFmpegSource will be linked to, here is the place to do it.
-
-If you want to compile WITH a given library, uncomment the corresponding #define.
-*/
-
-// OpenCore AMR narrowband (libopencore-amrnb.a)
-//#define	WITH_OPENCORE_AMR_NB
-
-// OpenCore AMR wideband (libopencore-amrwb.a)
-//#define	WITH_OPENCORE_AMR_WB
-
-// pthreads (libpthreadGC2.a)
-// Only works if libav/ffmpeg was built with gcc.
-//#define	WITH_PTHREAD_GC2
diff --git a/src/core/audiosource.cpp b/src/core/audiosource.cpp
index 9391f3070..886b7d66a 100644
--- a/src/core/audiosource.cpp
+++ b/src/core/audiosource.cpp
@@ -204,13 +204,10 @@ void FFMS_AudioSource::SetOutputFormat(FFMS_ResampleOptions const& opt) {
 	av_opt_set_int(newContext, "in_channel_layout", AP.ChannelLayout, 0);
 
 	av_opt_set_int(newContext, "out_sample_rate", opt.SampleRate, 0);
-
-#ifdef WITH_SWRESAMPLE
 	av_opt_set_channel_layout(newContext, "out_channel_layout", opt.ChannelLayout, 0);
 	av_opt_set_sample_fmt(newContext, "out_sample_fmt", (AVSampleFormat)opt.SampleFormat, 0);
-#endif
 
-	if (ffms_open_resampler(newContext))
+	if (swr_init(newContext))
 		throw FFMS_Exception(FFMS_ERROR_RESAMPLING, FFMS_ERROR_UNKNOWN,
 			"Could not open avresample context");
 	newContext.swap(ResampleContext);
@@ -231,9 +228,8 @@ void FFMS_AudioSource::ResampleAndCache(CacheIterator pos) {
 	auto dst = block.Grow(size);
 
 	uint8_t *OutPlanes[1] = { dst };
-	ffms_convert(ResampleContext,
-		OutPlanes, DecodeFrame->nb_samples, BytesPerSample, DecodeFrame->nb_samples,
-		DecodeFrame->extended_data, DecodeFrame->nb_samples, av_get_bytes_per_sample(CodecContext->sample_fmt), DecodeFrame->nb_samples);
+
+    swr_convert(ResampleContext, OutPlanes, DecodeFrame->nb_samples, (const uint8_t **)DecodeFrame->extended_data, DecodeFrame->nb_samples);
 }
 
 FFMS_AudioSource::AudioBlock *FFMS_AudioSource::CacheBlock(CacheIterator &pos) {
diff --git a/src/core/utils.h b/src/core/utils.h
index c31977178..cc746b1b4 100644
--- a/src/core/utils.h
+++ b/src/core/utils.h
@@ -29,12 +29,7 @@ extern "C" {
 #include <libavformat/avformat.h>
 #include <libavcodec/avcodec.h>
 #include <libswscale/swscale.h>
-
-#ifdef WITH_SWRESAMPLE
 #include <libswresample/swresample.h>
-#else
-#include <libavresample/avresample.h>
-#endif
 }
 
 // must be included after ffmpeg headers
@@ -127,7 +122,7 @@ class ScopedFrame : public unknown_size<AVFrame, av_frame_alloc, av_frame_free>
 	}
 };
 
-typedef unknown_size<FFMS_ResampleContext, ffms_resample_alloc_context, ffms_resample_free> FFResampleContext;
+typedef unknown_size<SwrContext, swr_alloc, swr_free> FFResampleContext;
 
 void ClearErrorInfo(FFMS_ErrorInfo *ErrorInfo);
 void InitNullPacket(AVPacket &pkt);
diff --git a/src/core/videoutils.cpp b/src/core/videoutils.cpp
index 5d14c5d0c..8918d0b9b 100644
--- a/src/core/videoutils.cpp
+++ b/src/core/videoutils.cpp
@@ -139,7 +139,7 @@ static int GetPseudoDepth(const AVPixFmtDescriptor &Desc) {
 	// Comparing the pseudo depth makes sure that rgb565-ish formats get selected over rgb555-ish ones
 	int depth = 0;
 	for (int i = 0; i < Desc.nb_components; i++)
-		depth = FFMAX(depth, FFMS_DEPTH(Desc.comp[i]));
+		depth = FFMAX(depth, Desc.comp[i].depth);
 	return depth;
 }
 
diff --git a/src/vapoursynth/vapoursource.cpp b/src/vapoursynth/vapoursource.cpp
index 9c4fa6060..11c7e5c01 100644
--- a/src/vapoursynth/vapoursource.cpp
+++ b/src/vapoursynth/vapoursource.cpp
@@ -40,11 +40,11 @@ static bool IsRealNativeEndianPlanar(const AVPixFmtDescriptor &desc) {
 	int used_planes = 0;
 	for (int i = 0; i < desc.nb_components; i++)
 		used_planes = std::max(used_planes, (int)desc.comp[i].plane + 1);
-	bool temp = (used_planes == desc.nb_components) && (FFMS_DEPTH(desc.comp[0]) >= 8) &&
+	bool temp = (used_planes == desc.nb_components) && (desc.comp[0].depth >= 8) &&
 		(!(desc.flags & FFMS_PIX_FMT_FLAG(PAL)));
 	if (!temp)
 		return false;
-	else if (FFMS_DEPTH(desc.comp[0]) == 8)
+	else if (desc.comp[0].depth == 8)
 		return temp;
 	else
 		return (FFMS_PIX_FMT(YUV420P10) == FFMS_PIX_FMT(YUV420P10BE) ? !!(desc.flags & FFMS_PIX_FMT_FLAG(BE)) : !(desc.flags & FFMS_PIX_FMT_FLAG(BE)));
@@ -76,7 +76,7 @@ static int FormatConversionToPixelFormat(int id, bool Alpha, VSCore *core, const
 			const AVPixFmtDescriptor &desc = *av_pix_fmt_desc_get((AVPixelFormat)i);
 			if (IsRealNativeEndianPlanar(desc) && !HasAlpha(desc)
 				&& GetColorFamily(desc) == f->colorFamily
-				&& FFMS_DEPTH(desc.comp[0]) == f->bitsPerSample
+				&& desc.comp[0].depth == f->bitsPerSample
 				&& desc.log2_chroma_w == f->subSamplingW
 				&& desc.log2_chroma_h == f->subSamplingH)
 				return i;
@@ -87,7 +87,7 @@ static int FormatConversionToPixelFormat(int id, bool Alpha, VSCore *core, const
 		const AVPixFmtDescriptor &desc = *av_pix_fmt_desc_get((AVPixelFormat)i);
 		if (IsRealNativeEndianPlanar(desc) && HasAlpha(desc)
 			&& GetColorFamily(desc) == f->colorFamily
-			&& FFMS_DEPTH(desc.comp[0]) == f->bitsPerSample
+			&& desc.comp[0].depth == f->bitsPerSample
 			&& desc.log2_chroma_w == f->subSamplingW
 			&& desc.log2_chroma_h == f->subSamplingH)
 			return i;
@@ -97,7 +97,7 @@ static int FormatConversionToPixelFormat(int id, bool Alpha, VSCore *core, const
 
 static const VSFormat *FormatConversionToVS(int id, VSCore *core, const VSAPI *vsapi) {
 	return vsapi->registerFormat(GetColorFamily(*av_pix_fmt_desc_get((AVPixelFormat)id)), stInteger,
-		FFMS_DEPTH(av_pix_fmt_desc_get((AVPixelFormat)id)->comp[0]),
+		av_pix_fmt_desc_get((AVPixelFormat)id)->comp[0].depth,
 		av_pix_fmt_desc_get((AVPixelFormat)id)->log2_chroma_w,
 		av_pix_fmt_desc_get((AVPixelFormat)id)->log2_chroma_h, core);
 }
